/*
 * set_stack_offset
 *
 * author: bennet yee <bsy@cs.ucsd.edu>, 2002-01-18.
 *
 * pads the environment so that the user stack is at a fixed offset.
 * this is done by counting the number of bytes already in use by the
 * environment and the argument list, and creating a new environment
 * variable of the appropriate size to pad out so the stack for the
 * exec'd process (after the kernel copies the environment to
 * consolidate it) will be at the appropriate location.
 *
 * some kernels may start every environment / argument string at a
 * word boundary.  the -s and -S flags allow the user to select this.
 * this could be automatically detected at run-time, but the argument
 * strings and environment could happen to all end at a word boundary,
 * in which case an additional exec would be necessary to perform this
 * detection.  the optimal choice would be to do this detection at
 * compile time and set the default appropriately.
 *
 * we do neither.  this is a one-off program, and so we merely
 * document the design choice here.
 *
 * similarly, the environment and arglist space may have a gap to move
 * to a word boundary.
 *
 * BUGS: works on sparc/solaris, but not on x86/linux.  on solaris the
 * stack is made to start at the same place every time; on linux it
 * can vary by 32 bytes.
 *
 * on intel processors stacks are more efficient if frames are 16-byte
 * aligned for the intel architecture, and the _start code performs
 * this alignment prior to doing anything else (shared library
 * loading/initialization, etc)
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define	TARGET		4096
#define	PACKED_STRINGS	1
#define	ARRAY_PAD	0

#if	sun
# define	PROGNAME_TWICE	1
# define	ROUND_PROGNAME	0
# define	PTR_ROUND	0
# define	inline
#elif	linux
# define	PROGNAME_TWICE	1
# define	ROUND_PROGNAME	0
# define	PTR_ROUND	0
#else
# define	PROGNAME_TWICE	0
# define	ROUND_PROGNAME	0
# define	PTR_ROUND	0
#endif

int		packed_str = PACKED_STRINGS;
int		array_pad = ARRAY_PAD;
int		progname_twice = PROGNAME_TWICE;
int		round_progname = ROUND_PROGNAME;
int		ptr_round = PTR_ROUND;

void usage(void) {
	fprintf(stderr,"Usage: set_stack_offset [-aApPrRsS] [-t target_size] [-u round-up-multple]\n");
}

unsigned int	round_incr = sizeof(char *) - 1;
unsigned int	mask = ~(sizeof(char *) - 1);

inline unsigned int	round_to_boundary(unsigned int	size)
{
	return (size + round_incr) & mask;
}

void		set_round_size(unsigned int	s)
{
	/* s is a power of 2 */
	if (s & (s-1)) {
		fprintf(stderr,"set_stack_size: round-to value must be a power of 2\n");
		exit(1);
	}
	round_incr = s-1;
	mask = ~round_incr;
}

unsigned int	bytes_in_str(char	*cp)
{
	if (packed_str) {
		return strlen(cp) + 1;
	} else {
		return round_to_boundary(strlen(cp) + 1);
	}
}

unsigned int	bytes_in_str_array(char **cpp)
{
	int	bc = sizeof(char *);
	/* the size of the null ptr that terminates the array is
           invariant wrt different executions, so doesn't really
           matter */
	char	*p;

	while (0 != (p = *cpp++)) {
		bc += sizeof(char *);
		bc += bytes_in_str(p);
	}
	return bc;
}

int main(int ac,
	 char **av,
	 char **envp)
{
	int		opt;
	int		in_use = 0;
	char		*p;
	unsigned int	target = TARGET;

	char		env_name[2];
	int		i;

	while (EOF != (opt = getopt(ac,av,"aApPrRsSt:u:"))) switch (opt) {
	case 'a':
		array_pad = 1;
		break;
	case 'A':
		array_pad = 0;
		break;
	case 'p':
		progname_twice = 1;
		break;
	case 'P':
		progname_twice = 0;
		break;
	case 'r':
		ptr_round = 1;
		break;
	case 'R':
		ptr_round = 0;
		break;
	case 's':
		packed_str = 1;
		break;
	case 'S':
		packed_str = 0;
		break;
	case 't':
		target = atoi(optarg);
		break;
	case 'u':
		set_round_size(atoi(optarg));
		break;
	default:
		usage(); exit(0);
	}

	if (progname_twice) {
		if (!round_progname) {
			in_use += bytes_in_str(av[optind]); /* put in top mem twice */
		} else {
			in_use += round_to_boundary(bytes_in_str(av[optind]));
		}
	}
	in_use += bytes_in_str_array(envp);
	/* padding between env array and arg array? */
	if (array_pad) {
		in_use = round_to_boundary(in_use);
	}
	in_use += bytes_in_str_array(av + optind);
	if (ptr_round) {
		in_use = round_to_boundary(in_use);
	}

	env_name[1] = '\0';
	/* assumes contiguous and increasing encoding for letters */
	for (env_name[0] = 'A'; env_name[0] <= 'Z'; env_name[0]++) {
		if (0 == getenv(env_name)) goto okay_name;
	}
	fprintf(stderr,"set_stack_offset: no candidate space-filler name found\n");
	exit(1);
 okay_name:
	if (target < in_use + 3 + sizeof(char *)) {
		fprintf(stderr,"set_stack_offset: target size too small\n");
		exit(1);
	}
	/*
	 * target >= in_use + 3 + sizeof(char *), so
	 * target - in_use - sizeof(char *) >= 3
	 *
	 * 3 because shortest is A=\0, and sizeof(char *) due to new
	 * entry in environment array
	 */
	target -= in_use - sizeof(char *);
	p = malloc(target);
	if (!p) {
		perror("set_stack_offset");
		exit(1);
	}
	p[0] = env_name[0]; p[1] = '=';
	for (i = 2; i < target; i++) {
		p[i] = 'a';
	}
	p[i-1] = 0;
	putenv(p);
	execv(av[optind],av + optind);
	perror("set_stack_offset");
	exit(1);
}
