#ifndef	lint
static char *copyright = "\n\
\n\
Copyright (c) 1994, 1998, 1999 by Bennet Yee.\n\
\n\
This material was developed by the author.  Permission to copy this\n\
software, to redistribute it, and to use it for any purpose is hereby\n\
granted, subject to the following five restrictions.\n\
\n\
1. Any copy made of this software must include this copyright notice in\n\
full.\n\
\n\
2. All materials containing this software or derivatives thereof must\n\
provide this software in source form or provide a means of obtaining\n\
this software in source form; no fees may be charged for this software\n\
except those for covering media costs and handling.\n\
\n\
3. All materials developed as a consequence of the use of this software\n\
shall duly acknowledge such use, in accordance with the usual standards\n\
of acknowledging credit in academic research.\n\
\n\
4. The author makes no warranty or representation that the operation\n\
of this software will be error-free, and the author is under no\n\
obligation to provide any services, by way of maintenance, update, or\n\
otherwise.\n\
\n\
5. In conjunction with products arising from the use of this material,\n\
there shall be no use of the names of the author, of Carnegie-Mellon\n\
University, nor of any adaptation thereof in any advertising,\n\
promotional, or sales literature without prior written consent from the\n\
author and Carnegie-Mellon University in each case.\n\
\n\
If you have questions, you can contact the author at bsy@cs.cmu.edu\n\
\n\
Users of this software is requested to make their best efforts (a) to\n\
return to the author any improvements or extensions that they make, so\n\
that these may be included in future releases; (b) to document clearly\n\
any improvements or extensions made to this software; and (c) to inform\n\
the author of noteworthy uses of this software.  Any improvements or\n\
extensions to this software may be placed under different copyright\n\
restrictions by the author of those improvements or extensions.  That\n\
those improvements or extensions be placed under the same copyright as\n\
this software is encouraged.\n\
";
#endif
/* lint */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <signal.h>
#include <ctype.h>
#include <stdio.h>
#include <sys/wait.h>
#include <string.h>

#include <stdlib.h>
#include <unistd.h>

#define	HOSTNAMEBUF	256

#define DEBUG		0

int	debug = 0, verbose = 0;

extern int	errno;

char	*me;
char	*machinename = (char *) 0, hostnamebuf[HOSTNAMEBUF];
char	*servicename = (char *) 0;

struct duplist { struct duplist *next; int desc; };
struct duplist dl0,dl1;

/*
 * this checks to see if an address looks like a dotted quad.
 *
 * the check is "loose" in that illegal strings are accepted as dotted
 * quads, i.e., "65535..2.", but since this is not a valid DNS name
 * anyway, it doesn't matter exactly how we get an error.
 */
int	dotted_quad_addr(char	*name)
{
	int	ch;

	while ((ch = *name++) != 0) switch (ch) {
	case '0': case '1': case '2': case '3':
	case '4': case '5': case '6': case '7':
	case '8': case '9': case '.':
		continue;
	default:
		return 0;
	}
	return 1;
}

void usage(void)
{
	fprintf(stderr,"Usage:  %s [-q] [-d N]... [-D] [-s service@host] cmd ...\n",me);
}

int main(int	ac,
	 char	**av)
{
	int			s, aliased;
	struct duplist		*desired = 0, *nd;
	char			*index();
	struct servent		*service;
	struct hostent		*host;
	struct sockaddr_in	saddrin;
	int			opt;

	(void) copyright; /* get rid of unused variable warning message */

	if ((me = strrchr(av[0],'/')) != 0) ++me; else me = av[0];
	while ((opt = getopt(ac,av,"d:Ds:v")) != EOF) switch (opt) {
	case 'd':
		nd = (struct duplist *) malloc(sizeof *nd);
		if (!nd) { perror(me); exit(1);}
		nd->desc = atoi(optarg);
		nd->next = desired;
		desired = nd; break;
	case 'D':	debug = 1;		break;
	case 's':	servicename = optarg;	break;
	case 'v':	verbose = 1;		break;
	default:
		fprintf(stderr,"%s:  unknown switch %c\n",me,opt);
		usage();
		exit(1);
	}
	if (optind == ac) {
		fprintf(stderr,"%s: no command?\n",me);
		usage();
		exit(1);
	}
	if (!desired) {
		desired = &dl0;
		dl0.desc = 0; dl0.next = &dl1;
		dl1.desc = 1; dl1.next = 0;
	}
	for (nd = desired; nd; nd = nd->next) {
		/* try it out and make sure it is a valid descriptor number */
		if (dup2(0,nd->desc) == -1) {
			perror(me);
			fprintf(stderr,"%s:  %d is not usable as a descriptor\n",me,nd->desc);
		}
		/*
		 * no need to close, subsequent dup2 will fix it.
		 * Furthermore, we now know that s will not collide
		 * with a user supplied descriptor.
		 */
	}
	if (!servicename) {
		fprintf(stderr,"%s: must name to which server to connect\n",me);
		usage(); exit(1);
	}
	machinename = strchr(servicename,'@');
	if (!machinename) {
		if (gethostname(hostnamebuf,HOSTNAMEBUF) == -1) {
			perror(me);
			fprintf(stderr,"%s:  where am I?!?\n",me);
			exit(1);
		}
		machinename = hostnamebuf;
	} else {
		*machinename = 0;
		machinename++;
	}

	/*
	 * This assumes no service names start with a digit.
	 */
	if (isdigit((int) *servicename)) {
		static struct servent srv;
		service = &srv;
		srv.s_proto = 0; /* no protoname */
		srv.s_port = atoi(servicename);
		srv.s_port = htons(srv.s_port);
		/* separated in case htons is a macro */
	} else {
		if (!(service = getservbyname(servicename,"tcp"))) {
			fprintf(stderr,"%s:  can not find %s tcp service\n",me,servicename);
			exit(1);
		}
	}

	if ((s = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP)) == -1) {
		perror(me);
		fprintf(stderr,"%s: errno = %d\n",me,errno);
		exit(1);
	}

	memset((char *) &saddrin,0,sizeof saddrin);
	if (!dotted_quad_addr(machinename)) {
		if (!(host = gethostbyname(machinename))) {
			fprintf(stderr,"%s:  can not get host info for %s\n",me,machinename);
			exit(1);
		}
		memcpy((char *) &saddrin.sin_addr,host->h_addr,host->h_length);
	} else {
		saddrin.sin_addr.s_addr = inet_addr(machinename);
	}
	saddrin.sin_family = AF_INET;
	saddrin.sin_port = service->s_port;

	if (debug) {
		fprintf(stderr,"%s: obtaining a connection with socket %x\n",me,s);
		fprintf(stderr,"%s: connecting to address family %d, address %s, and port %d\n",me,saddrin.sin_family,inet_ntoa(saddrin.sin_addr),ntohs(saddrin.sin_port));
	}

	if (connect(s,(struct sockaddr *) &saddrin,sizeof saddrin) == -1) {
		perror(me);
		fprintf(stderr,"%s: errno = %d\n",me,errno);
		exit(1);
	}

	if (verbose) fprintf(stderr,"CONNECTED\n");

	aliased = 0;
	for (nd = desired; nd; nd = nd->next) {
		if (s != nd->desc)
			dup2(s,nd->desc);
		else
			aliased = 1;
	}
	if (!aliased) (void) close(s);

	execvp(av[optind],av+optind);
	perror(me);
	fprintf(stderr,"%s: can not exec %s\n",me,av[optind]);
	return 1;
}
