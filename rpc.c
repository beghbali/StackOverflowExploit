#ifndef	lint
static char *copyright = "\n\
Copyright (c) 1999, 2002 by Bennet Yee <bsy@cs.ucsd.edu>.\n\
\n\
This material was developed by the author.  Permission to copy this\n\
software, to redistribute it, and to use it for any purpose is hereby\n\
granted, subject to the following five restrictions.\n\
\n\
1. Any copy made of this software must include this copyright notice in\n\
full.\n\
\n\
2. All materials containing this software or derivatives thereof must\n\
provide this software in source form or provide a means of obtaining\n\
this software in source form; no fees may be charged for this software\n\
except those for covering media costs and handling.\n\
\n\
3. All materials developed as a consequence of the use of this software\n\
shall duly acknowledge such use, in accordance with the usual standards\n\
of acknowledging credit in academic research.\n\
\n\
4. The author makes no warranty or representation that the operation\n\
of this software will be error-free, and the author is under no\n\
obligation to provide any services, by way of maintenance, update, or\n\
otherwise.\n\
\n\
5. In conjunction with products arising from the use of this material,\n\
there shall be no use of the names of the author, of the University of\n\
California, nor of any adaptation thereof in any advertising,\n\
promotional, or sales literature without prior written consent from the\n\
author and the University of California in each case.\n\
\n\
If you have questions, you can contact the author at bsy@cs.ucsd.edu\n\
\n\
Users of this software is requested to make their best efforts (a) to\n\
return to the author any improvements or extensions that they make, so\n\
that these may be included in future releases; (b) to document clearly\n\
any improvements or extensions made to this software; and (c) to inform\n\
the author of noteworthy uses of this software.  Any improvements or\n\
extensions to this software may be placed under different copyright\n\
restrictions by the author of those improvements or extensions.  That\n\
those improvements or extensions be placed under the same copyright as\n\
this software is encouraged.\n\
";
#endif
/* lint */

/*
 * simple rpc system scaffolding.
 *
 * 4/2/99, -bsy
 *
 * rpc stubs are explicit.  user must supply mux/demux routines.
 */

#ifndef	DEBUG
# define	DEBUG	0
#endif
#include <stdio.h>
#include <unistd.h>
#include <netinet/in.h>

#include "rpc.h"

/* 0 is default value, so DOUBLE_BYTE_ORDER defaults to generating error */
#define	DOUBLE_MSB_FIRST	1
#define	DOUBLE_LSB_FIRST	2

void	srss_rewind_request(struct srss_state	*sp)
{
	sp->in_ix = 0;
}

void	srss_rewind_reply(struct srss_state	*sp)
{
	sp->out_ix = 0;
}

uint32_t	srss_get_uint32(struct srss_state	*sp)
{
	uint32_t	num;

	memcpy(&num,&sp->in_buf[sp->in_ix],sizeof num);
	sp->in_ix += sizeof num;
	return ntohl(num);
}

void	srss_set_uint32(struct srss_state	*sp,
			uint32_t		v)
{
	uint32_t	num = htonl(v);

	memcpy(&sp->out_buf[sp->out_ix],&num,sizeof num);
	sp->out_ix += sizeof num;
}

uint16_t	srss_get_uint16(struct srss_state	*sp)
{
	uint16_t	num;

	memcpy(&num,&sp->in_buf[sp->in_ix],sizeof num);
	sp->in_ix += sizeof num;
	return ntohs(num);
}

void srss_set_uint16(struct srss_state	*sp,
		     uint16_t		v)
{
	uint16_t	num = htons(v);

	memcpy(&sp->out_buf[sp->out_ix],&num,sizeof num);
	sp->out_ix += sizeof num;
}

char *srss_get_str(struct srss_state	*sp)
{
	char	*str;
	int	len;

	str = sp->in_buf + sp->in_ix;
	len = strlen(str);
	sp->in_ix += len + 1;	/* null */
	return str;
}

void srss_set_str(struct srss_state	*sp,
		  char			*s)
{
	char	*str;
	int	len;

	str = sp->out_buf + sp->out_ix;
	len = strlen(s);
	strcpy(str,s);
	sp->out_ix += len + 1;	/* null */
}

double srss_get_double(struct srss_state	*sp)
{
	/*
	 * Assumes IEEE 754 floating point standard.
	 *
	 * XXX -- assumes that DOUBLE_LSB_FIRST and DOUBLE_MSB_FIRST are
	 * the only choices.  Our network format is DOUBLE_MSB_FIRST
	 */
	double	v;

#if	DOUBLE_BYTE_ORDER == DOUBLE_LSB_FIRST
	int	i;
	char	*vp = (char *) &v, *bp = sp->in_buf + sp->in_ix;

	for (i = sizeof v; --i >= 0;) {
		*vp++ = *bp++;
	}
#elif	DOUBLE_BYTE_ORDER == DOUBLE_MSB_FIRST
	memcpy(&v,sp->in_buf + sp->in_ix,sizeof v);
#else
	generate a compiler error here!;
#endif
	sp->in_ix += sizeof v;

	return v;
}

void srss_set_double(struct srss_state	*sp,
		     double		v)
{
	/*
	 * XXX -- assumes that DOUBLE_LSB_FIRST and DOUBLE_MSB_FIRST are
	 * the only choices.  Our network format is DOUBLE_MSB_FIRST
	 */

#if	DOUBLE_BYTE_ORDER == DOUBLE_LSB_FIRST
	int	i;
	char	*vp = (char *) &v, *bp = sp->out_buf + sp->out_ix;

	for (i = sizeof v; --i >= 0;) {
		*bp++ = *vp++;
	}
#elif	DOUBLE_BYTE_ORDER == DOUBLE_MSB_FIRST
	memcpy(sp->out_buf + sp->out_ix,&v,sizeof v);
#else
	generate a compiler error here!;
#endif
	sp->out_ix += sizeof v;
}

int	srss_unmarshall(struct srss_state	*sp,
			char			*fmt,
			...)
{
	char		t;
	int		half = 0, dp_not_fp = 0, count = 0;
	char		*cp, *str;
	uint32_t	*ip;
	uint16_t	*hip;
	double		*dp; float *fp;
	va_list		ap;

	va_start(ap,fmt);
	while ((t = *fmt++) != 0) switch (t) {
	case 'h':
		half = 1;
		break;
	case 'l':
		dp_not_fp = 1;
		break;
	case 's':
		cp = va_arg(ap,char *);
		str = srss_get_str(sp);
		strcpy(cp,str);
		/* parsed, but DCE'd when DEBUG 0 */
		if (DEBUG) {
			fprintf(stderr,"unmarshalled str: %s\n",str);
		}
		count++;
		half = 0; dp_not_fp = 0;
		break;
	case 'd':
		if (half) {
			hip = va_arg(ap,uint16_t *);
			*hip = srss_get_uint16(sp);
			if (DEBUG) {
				fprintf(stderr,"unmarshalled uint16: %d\n",*hip);
			}
		} else {
			ip = va_arg(ap,uint32_t *);
			*ip = srss_get_uint32(sp);
			if (DEBUG) {
				fprintf(stderr,"unmarshalled uint32: %d\n",*ip);
			}
		}
		count++;
		half = 0; dp_not_fp = 0;
		break;
	case 'f':
		if (!dp_not_fp) {
			fp = va_arg(ap,float *);
			*fp = (float) srss_get_double(sp);
			if (DEBUG) {
				fprintf(stderr,"unmarshalled float: %f\n",*fp);
			}
		} else {
			dp = va_arg(ap,double *);
			*dp = srss_get_double(sp);
			if (DEBUG) {
				fprintf(stderr,"unmarshalled double: %f\n",*dp);
			}
		}
		count++;
		half = 0; dp_not_fp = 0;
		break;
	default:
		return count;
	}
	va_end(ap);
	return count;
}

int	srss_marshall(struct srss_state	*sp,
		      char		*fmt,
		      ...)
{
	char		t;
	int		half = 0, dp_not_fp = 0, count = 0;
	char		*cp;
	uint32_t	iv;
	uint16_t	hiv;
	double		dv; float fv;
	va_list		ap;

	va_start(ap,fmt);
	while ((t = *fmt++) != 0) switch (t) {
	case 'h':
		half = 1;
		break;
	case 'l':
		dp_not_fp = 1;
		break;
	case 's':
		cp = va_arg(ap,char *);
		srss_set_str(sp,cp);
		if (DEBUG) {
			fprintf(stderr,"marshalled str: %s\n",cp);
		}
		count++;
		half = 0; dp_not_fp = 0;
		break;
	case 'd':
		if (half) {
			hiv = va_arg(ap,uint16_t);
			srss_set_uint16(sp,hiv);
			if (DEBUG) {
				fprintf(stderr,"marshalled uint16: %d\n",hiv);
			}
		} else {
			iv = va_arg(ap,uint32_t);
			srss_set_uint32(sp,iv);
			if (DEBUG) {
				fprintf(stderr,"marshalled uint32: %d\n",iv);
			}
		}
		count++;
		half = 0; dp_not_fp = 0;
		break;
	case 'f':
		if (!dp_not_fp) {
			fv = va_arg(ap,float);
			srss_set_double(sp,fv);
			if (DEBUG) {
				fprintf(stderr,"marshalled float: %f\n",fv);
			}
		} else {
			dv = va_arg(ap,double);
			srss_set_double(sp,dv);
			if (DEBUG) {
				fprintf(stderr,"marshalled double: %f\n",dv);
			}
		}
		count++;
		half = 0; dp_not_fp = 0;
		break;
	default:
		return count;
	}
	va_end(ap);
	return count;
}

void srss_init_internal(struct srss_state	*state,
			int			sock)
{
	state->sock = sock;
	/*
	 * we don't know whether this is the client or the server yet.
	 * the I/O buffering and marshalling/unmarshalling code is the
	 * same.
	 */
	state->in_ix = state->out_ix = 0;
	memset(state->in_buf, 0,MAX_RPC_SIZE);
	memset(state->out_buf,0,MAX_RPC_SIZE);
}

void srss_server_init(struct srss_state	*state,
		      int		nentries,
		      struct srss_entry	*entry_pts,
		      int		sock)
{
	srss_init_internal(state,sock);
	state->num_entries = nentries;
	state->entry_pts = entry_pts;
}

void srss_client_init(struct srss_state	*state,
		      int		sock)
{
	srss_init_internal(state,sock);
	state->num_entries = 0;
	state->entry_pts = 0;
}

/*
 * debug utility
 */
void srss_dump_mem(FILE		*iob,
		   char		*mem,
		   int		count)
{
	int	i;

	for (i = 0; i < count; i++) {
		fprintf(iob," %02x",mem[i]);
		if ((i & 0xf) == 0xf) fputc('\n',iob);
	}
	fputc('\n',iob);
}

/*
 * server-side only
 *
 * the calling thread will now handle RPCs over the server socket
 * specified by the state variable.
 */
int srss_service(struct srss_state	*state,
		 int			ignore_recoverable_errors)
{
	int			rpc_num, packet_size, nbytes;
	struct srss_entry	*entry;

#define	barf(c)	do { if (!ignore_recoverable_errors && (c)) return (c); } while (0)

	for (;;) {
		if (read(state->sock,&rpc_num,sizeof rpc_num) != sizeof rpc_num)
			return SRSS_BAD_READ;
		rpc_num = ntohl(rpc_num);
		if (DEBUG) {
			fprintf(stderr,"Got rpc request #%d\n",rpc_num);
		}

		entry = &state->entry_pts[rpc_num];
		if (read(state->sock,&packet_size,sizeof packet_size) != sizeof packet_size)
			return SRSS_BAD_READ;
		packet_size = ntohl(packet_size);
		if (DEBUG) {
			fprintf(stderr,"arglist size %d\n",packet_size);
		}
		if (packet_size > MAX_RPC_SIZE)
			return SRSS_BAD_RPC_SIZE;
		if ((nbytes = read(state->sock,state->in_buf,packet_size)) != packet_size)
			return SRSS_BAD_READ;
		if (DEBUG) {
			fprintf(stderr,"\npacket:\n\n");
			srss_dump_mem(stderr,state->in_buf,packet_size);
		}
		if (!entry->rpc_handler) {
			/*
			 * deprecated entry -- use a NULL ptr to indicate
			 * that an RPC entry point is now obsolete
			 * (this allows versioning).
			 */
			if (DEBUG) {
				fprintf(stderr,"deprecated interface, ignored\n");
			}
			barf(SRSS_BAD_RPC_ENTRY);
			continue;
		}
		if (DEBUG) {
			fprintf(stderr,"calling %s with %d bytes of input\n",entry->rpc_name,nbytes);
		}
		state->in_ix = 0; state->out_ix = 0;
		(*entry->rpc_handler)(state);
		/* send reply */
		if (DEBUG) {
			fprintf(stderr,"replying with %d bytes of data\n",state->out_ix);
			srss_dump_mem(stderr,state->out_buf,state->out_ix);
		}
		nbytes = htonl(state->out_ix);
		
		if (write(state->sock,&nbytes,sizeof nbytes) != sizeof nbytes) {
			return SRSS_BAD_WRITE;
		}
		if (state->out_ix && write(state->sock,state->out_buf,state->out_ix) != state->out_ix) {
			return SRSS_BAD_WRITE;
		}
	}
}
#undef barf

/* client-side */
int srss_rpc(struct srss_state	*sp,
	     int		rpc_num)
{
	int	nbytes;

	(void) copyright; /* get rid of unused variable warning message */
	rpc_num = htonl(rpc_num);
	if (write(sp->sock,&rpc_num,sizeof rpc_num) != sizeof rpc_num)
		return SRSS_BAD_WRITE;
	if ((nbytes = sp->out_ix) != 0) {
		nbytes = htonl(nbytes);
		if (write(sp->sock,&nbytes,sizeof nbytes) != sizeof nbytes)
			return SRSS_BAD_WRITE;
		if (write(sp->sock,sp->out_buf,sp->out_ix) != sp->out_ix)
			return SRSS_BAD_WRITE;
	}
	/*
	 * block waiting for the reply.  this is what distinguishes
	 * RPCs from just plain message passing -- the abstraction for
	 * the programmer is that it looks like a normal procedure
	 * call, and normal procedure calls don't return until the
	 * procedure has completed.
	 */
	if (read(sp->sock,&nbytes,sizeof nbytes) != sizeof nbytes)
		return SRSS_BAD_READ;
	nbytes = ntohl(nbytes);
	if (nbytes && read(sp->sock,sp->in_buf,nbytes) != nbytes)
		return SRSS_BAD_READ;
	/* success -- user code must read out the reply msg */
	return nbytes;
}
