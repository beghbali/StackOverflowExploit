#ifndef	lint
static char *copyright = "\n\
\n\
Copyright (c) 1993, 1996, 1999, 2002 by Bennet Yee.\n\
\n\
This material was developed by the author.  Permission to copy this\n\
software, to redistribute it, and to use it for any purpose is hereby\n\
granted, subject to the following five restrictions.\n\
\n\
1. Any copy made of this software must include this copyright notice in\n\
full.\n\
\n\
2. All materials containing this software or derivatives thereof must\n\
provide this software in source form or provide a means of obtaining\n\
this software in source form; no fees may be charged for this software\n\
except those for covering media costs and handling.\n\
\n\
3. All materials developed as a consequence of the use of this software\n\
shall duly acknowledge such use, in accordance with the usual standards\n\
of acknowledging credit in academic research.\n\
\n\
4. The author makes no warranty or representation that the operation\n\
of this software will be error-free, and the author is under no\n\
obligation to provide any services, by way of maintenance, update, or\n\
otherwise.\n\
\n\
5. In conjunction with products arising from the use of this material,\n\
there shall be no use of the names of the author, of Carnegie-Mellon\n\
University, nor of any adaptation thereof in any advertising,\n\
promotional, or sales literature without prior written consent from the\n\
author and Carnegie-Mellon University in each case.\n\
\n\
If you have questions, you can contact the author at bsy@cs.cmu.edu\n\
\n\
Users of this software is requested to make their best efforts (a) to\n\
return to the author any improvements or extensions that they make, so\n\
that these may be included in future releases; (b) to document clearly\n\
any improvements or extensions made to this software; and (c) to inform\n\
the author of noteworthy uses of this software.  Any improvements or\n\
extensions to this software may be placed under different copyright\n\
restrictions by the author of those improvements or extensions.  That\n\
those improvements or extensions be placed under the same copyright as\n\
this software is encouraged.\n\
";
#endif	/* lint */

/*
 * revised 2/23/02.  -bsy
 *
 * server code based on pseudo-inetd.  this implements a basic rpc system
 * that is single-threaded.
 *
 * 3/26/99, -bsy
 *
 * pseudo-inetd -- new sources, not based on Berklix/AT&T code.
 *
 * First pass:  much more limited that inetd -- no configuration table,
 * we just listen to a particular tcp socket as specified at the command line
 * and then run a inetd-style server program with the socket at stdin/out.
 *
 * Hacked from my how.to/tcp.client.server/server.c
 *
 * 12/13/90, -bsy
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <ctype.h>
#include <syslog.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <sys/file.h>
#if	!defined(posix_tty)
# include <sgtty.h>
#endif
#include <netinet/in.h>
#include <sys/errno.h>
#include <string.h>
#if	!defined(O_APPEND)
# include <sys/fcntl.h>
#endif

#include "rpc_service.h"

#define	CHEESY_TEST	0
#if	CHEESY_TEST
void	cheesy_test(void)
{
	printf("This is a cheesy test\n");
	exit(0);
}
#endif

extern int	errno;

char		*me;

#define	SERVERPORT	5103

unsigned long	servers_allowed = ~0ul;
int		verbose = 0;

void reaper(void)
{
	/* old linux / SysV style reenablement, bletch */
#if	!defined(USE_SIGSET)
	(void) signal(SIGCHLD,(void (*)(int)) reaper);
#endif
	if (verbose) write(2,"reaper: ",8);
#if	defined(_POSIX_VERSION)
	if (wait((int *) 0) > 0) {
		++servers_allowed;
		if (verbose) write(2,".",1);
	}
#else
	if (wait((union wait *) 0) > 0) {
		++servers_allowed;
		if (verbose) write(2,".",1);
	}
#endif
	if (verbose) write(2," reaped\n",8);
}

void usage(void)
{
	fprintf(stderr,"Usage:  %s [-dlv] [-p port] [-c count-to-exit] [-s server-count-limit] [-D descriptor-num]\n",me);
}

int main(int	ac,
	 char	**av)
{
	int			s, ss;
	struct sockaddr_in	name;
	int			set,ch,namelen;
#if	defined(TIOCNOTTY)
	int			detach;
#endif
	u_short			port = SERVERPORT;
	int			log = 0, count = -1;

	extern int		getopt(), optind;
	extern char		*optarg;

	(void) copyright; /* get rid of unused variable warning message */

	me = strrchr(av[0],'/');
	if (!me) me = av[0]; else ++me;

#if	defined(TIOCNOTTY)
	detach = 0;
#endif
	while ((ch = getopt(ac,av,"c:lLp:s:Dv")) != EOF) switch (ch) {
	case 'c':	count = atoi(optarg);		break;
	case 'l':	log = 1;			break;
	case 'L':	log = 0;			break;
	case 'p':	port = atoi(optarg);		break;
	case 's':	servers_allowed = atoi(optarg);	break;
#if	defined(TIOCNOTTY)
	case 'D':	detach = 1;			break;
#else
	case 'D':
		fprintf(stderr,"%s:  detach option ignored; POSIX has no way to force a disassociation\n from the control terminal except implicitly through process group\n orphanhood.\n",me);
		break;
#endif
	case 'v':	verbose++;			break;
	default:	usage(); exit(1);
	}

	if (verbose) {
		printf("Address of sockaddr is %p\n",&name);
	}
#if	defined(TIOCNOTTY)
	if (detach) {
		int i;
		i = open("/dev/tty",O_RDONLY,0);
		if (i != -1) {
			(void) ioctl(i,TIOCNOTTY,(char *) 0);
			(void) close(i);
		}
	}
#endif
	if ((s = socket(PF_INET,SOCK_STREAM,0)) == -1) {
		perror("socket");
		exit(1);
	}

	set = 1;
	if (setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(const char *) &set, sizeof(set)) == -1) {
		perror("setsockoopt");
		exit(1);
	}

	memset((char *)&name,0,sizeof(name));
	name.sin_family = AF_INET;
	name.sin_port = htons(port);

	if (bind(s,(struct sockaddr *) &name,sizeof(name)) == -1) {
		perror("bind");
		exit(1);
	}

	/* backlogs?  how many client at a time? */
	if (listen(s,4) == -1) {
		perror("listen");
		exit(1);
	}

#if	USE_SIGSET
	(void) sigset(SIGCHLD,(void (*)(int)) reaper);
#else
	/* linux, bsd */
	(void) signal(SIGCHLD,(void (*)(int)) reaper);
#endif
again:
	while ((namelen = sizeof name), ((ss = accept(s,(struct sockaddr *)&name,&namelen)) != -1)) {
		if (verbose) {
			/* we do not use the other sockaddr info */
			fprintf(stderr,"[%s]\n",inet_ntoa(name.sin_addr));
		}
		if (log) {
			char	buf[256];
			sprintf(buf,"rpc_server: Connect on port %d from %s",port,inet_ntoa(name.sin_addr));
			syslog(LOG_INFO | LOG_DAEMON,buf);
		}
#if	CHEESY_TEST
		rpc_service(ss);
		exit(0);
#else
		/* run prog */
		switch (fork()) {
		case 0:
			(void) close(s);

			rpc_service(ss);

			exit(0);
		case -1:
			perror("fork");
			exit(1);
		default:
			(void) close(ss);
			--servers_allowed;
			break;
		}
		if (count > 0 && --count == 0) exit(0);
		while (!servers_allowed) {
			if (verbose) fprintf(stderr,"Pausing\n");
			pause();
			if (verbose) fprintf(stderr,"paused, servers_allowed %ld\n",servers_allowed);
		}
#endif
	}
	if (errno == EINTR) goto again;
	perror("accept");
	exit(1);
	/* NOTREACHED */
}
